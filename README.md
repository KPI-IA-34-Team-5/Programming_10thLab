# Лабораторна робота №10
## Тема: Функціональні інтерфейси та лямбда-вирази
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
## Контрольні питання:
### 1. В чому полягають відмінності, переваги та недоліки лямбда-виразів у порівнянні з анонімними класами?

Ось деякі відмінності, переваги та недоліки лямбда-виразів у порівнянні з анонімними класами:

**Відмінності:**

1. **Синтаксична компактність:** Лямбда-вирази зазвичай коротші та більш компактні, що робить код більш зрозумілим та менш обтяжлим порівняно з анонімними класами.

2. **Необов'язковість типів параметрів:** У лямбда-виразах можна не вказувати типи параметрів, якщо компілятор може визначити їх автоматично за контекстом.

3. **Необов'язковість фінальних змінних:** Лямбда-вирази мають доступ до змінних з зовнішнього контексту без необхідності робити їх фінальними, або ж явно вказувати їх як `final`.

**Переваги лямбда-виразів:**

1. **Зручність та зрозумілість:** Лямбда-вирази спрощують роботу з функціями, переданими як параметри методів або інтерфейсів. Вони дозволяють зосередитися на самому функціональному аспекті коду, а не на деталях створення анонімних класів.

2. **Менше коду:** Благодаря компактності лямбда-виразів, код стає меншим та більш зрозумілим, особливо у випадках, коли потрібно написати коротку логіку.

3. **Легша читабельність:** У випадках, коли лямбда-вирази використовуються в одноразових функціях, вони можуть зробити код більш зрозумілим, оскільки логіка виразу зазвичай відображається безпосередньо в коді, без додаткового шуму.

**Недоліки лямбда-виразів:**

1. **Обмеженість використання:** Лямбда-вирази призначені для простих функціональних інтерфейсів, тому вони можуть бути неефективними або непридатними для складних сценаріїв.

2. **Потенційні проблеми зі структурою коду:** Велика кількість лямбда-виразів у великому проекті може призвести до меншої структурованості коду та складнощів у його розумінні.

У кожному конкретному випадку вибір між лямбда-виразами та анонімними класами залежить від конкретних потреб та вимог вашого проекту.

### 2. Що таке функціональний інтерфейс?

Функціональний інтерфейс (Functional Interface) - це інтерфейс в Java, який містить тільки один абстрактний метод. Функціональні інтерфейси введені в Java 8 для підтримки функціонального програмування та використання лямбда-виразів.

Основні характеристики функціональних інтерфейсів:

1. **Абстрактний метод:** Функціональний інтерфейс містить один абстрактний метод, який не має реалізації і повинен бути перевизначений в класах, що реалізують цей інтерфейс.

2. **Декларація за допомогою анотації `@FunctionalInterface`:** Щоб позначити інтерфейс як функціональний, можна використовувати анотацію `@FunctionalInterface`. Ця анотація слугує як підказка для компілятора, що інтерфейс призначений для використання у функціональному програмуванні.

3. **Може містити додаткові методи з реалізацією за замовчуванням:** Окрім абстрактного методу, функціональний інтерфейс може містити методи з реалізацією за замовчуванням (default methods) і статичні методи. Однак кількість абстрактних методів повинна бути рівна одному.

Функціональні інтерфейси дозволяють використовувати лямбда-вирази, що є коротким способом створення реалізації для абстрактних методів функціональних інтерфейсів. Це дозволяє писати більш компактний та зрозумілий код, особливо в контексті функціонального програмування.

### 3. Що таке статичні та дефолтні методи? Чим вони відрізняються від звичайних методів в інтерфейсах?

Статичні та дефолтні методи є особливими видами методів в інтерфейсах Java, які були додані у Java 8 для підтримки нових функцій, таких як лямбда-вирази та функціональні інтерфейси. Ось їхні основні відмінності від звичайних методів інтерфейсів:

1. **Статичні методи:**

   - **Визначення:** Статичні методи в інтерфейсах оголошуються зі словом-модифікатором `static`.
   
   - **Використання:** Статичні методи можна викликати без створення екземпляра класу, просто використовуючи ім'я інтерфейсу.
   
   - **Функціональність:** Статичні методи в інтерфейсах можуть містити реалізацію за замовчуванням, яка надає специфічну функціональність.

2. **Дефолтні методи:**

   - **Визначення:** Дефолтні методи в інтерфейсах оголошуються зі словом-модифікатором `default`.
   
   - **Використання:** Дефолтні методи можна унаслідувати в класі, який реалізує цей інтерфейс. Це дає змогу додати нові функціональності в існуючий інтерфейс без порушення сумісності з вже існуючими реалізаціями інтерфейсу.
   
   - **Функціональність:** Дефолтні методи можуть мати реалізацію за замовчуванням, яка надає базову реалізацію метода, але цей метод можна перевизначити у класі, який реалізує інтерфейс.

Відмінність від звичайних методів в інтерфейсах полягає у тому, що звичайні методи (тобто без модифікатора `default` або `static`) у Java інтерфейсах не можуть мати реалізації. Вони залишаються абстрактними і повинні бути перевизначені у класах, які реалізують інтерфейс. Статичні та дефолтні методи дозволяють додавати функціональність в інтерфейси, що значно розширює можливості цього механізму в Java.

### 4. Чому з лямбда-виразів неможна звертатись до локальних змінних, що змінюють свої значення?

Лямбда-вирази в Java не можуть звертатися до локальних змінних, які змінюють своє значення, оскільки вони повинні мати фіксоване значення або бути final або effectively final (тобто значення не змінюється після присвоєння).

Така обмеженість виникає з того, що лямбда-вирази можуть бути виконані пізніше, у різний час після того, як локальна змінна була оголошена. Це може призвести до ситуації, коли значення локальної змінної змінюється після створення лямбда-виразу, що може викликати непередбачувану поведінку.

Враховуючи це, компілятор Java вимагає, щоб локальні змінні, які використовуються в лямбда-виразах, були final або effectively final. Такі змінні не можуть змінювати свої значення після того, як вони були присвоєні вперше. Це дозволяє забезпечити безпеку та передбачуваність у використанні лямбда-виразів в Java.

Зазвичай ця обмеженість не є проблемою, оскільки лямбда-вирази зазвичай використовуються для передачі логіки в методах або функціях, де їхній доступ до зовнішніх змінних не має значення за межами контексту, де вони використовуються.

### 5. В чому полягає різниця між поняттями «final» та «effectively final»?

Поняття "final" та "effectively final" в Java відносяться до модифікаторів змінних і мають свої відмінності:

1. **Final змінна:**
   - **Визначення:** Змінна, оголошена з модифікатором `final`, не може бути змінена після присвоєння свого значення. Тобто вона має постійне, незмінне значення.
   - **Приклад:**
     ```java
     final int x = 10;
     // Не можна змінювати значення змінної x
     // x = 15; // Помилка компіляції
     ```

2. **Effectively Final змінна:**
   - **Визначення:** Змінна вважається "effectively final", якщо вона не змінює свого значення після того, як була присвоєна вперше. Це означає, що вона має фактично постійне значення в контексті, де вона використовується.
   - **Приклад:**
     ```java
     int y = 20;
     // Змінна y є "effectively final", оскільки її значення не змінюється після присвоєння
     // y = 25; // Помилка компіляції, оскільки y вже використовується як "effectively final"
     ```

Різниця між ними полягає у тому, що `final` є явним модифікатором, що позначає, що змінна є константою з постійним значенням, тоді як "effectively final" вказує на те, що змінна не змінює свого значення після присвоєння, але вона не оголошена як `final`. "Effectively final" стає важливим у контексті лямбда-виразів, оскільки забезпечує можливість використання локальних змінних у лямбда-виразах, якщо вони не змінюються після присвоєння.

### 6. В яких випадках використовується інтерфейс Consumer?

Інтерфейс `Consumer` в Java використовується для реалізації функціональності, яка приймає вхідний параметр, але не повертає жодного значення (нульовий тип). Він входить в комплект функціональних інтерфейсів в пакеті `java.util.function` і є одним із найбільш широко використовуваних інтерфейсів у функціональному програмуванні Java. Основні випадки використання інтерфейсу `Consumer` включають:

1. **Обробка даних:**
   - Інтерфейс `Consumer` може бути використаний для обробки або виконання операцій над даними, що передаються як вхідний параметр. Наприклад, ви можете використовувати його для виводу даних у консоль, запису у файл, відправлення на сервер і т.д.

2. **Ланцюжок обробки даних:**
   - `Consumer` добре підходить для створення ланцюжків обробки даних, де ви можете послідовно виконувати операції над даними.
   - Наприклад, ви можете скласти ланцюжок `Consumer`, що виконує послідовно кілька операцій: фільтрування, сортування, обробку тощо.

3. **Функціональне програмування:**
   - Використання `Consumer` є типовим у функціональному програмуванні, де функції часто використовуються як аргументи методів або вирази в стилі лямбда-виразів.
   - Наприклад, ви можете використовувати `Consumer` для виконання певних дій над кожним елементом колекції або стріму.

4. **Обробка подій:**
   - У графічному інтерфейсі користувача (GUI) часто використовуються `Consumer` для обробки подій від користувача, таких як натискання кнопок, введення тексту, переміщення миші тощо.

5. **Робота з API:**
   - Деякі API можуть приймати `Consumer` в якості параметра для виконання певних дій у визначеному контексті.
  
В цілому, `Consumer` є потужним інструментом для реалізації функціональності, яка приймає дані, обробляє їх і не повертає результат. Він допомагає створювати компактний та зрозумілий код, особливо у випадках, коли потрібно виконати послідовні дії над даними або обробити велику кількість об'єктів.

### 7. Поясніть різницю між <? super T> та <? extends T>. В яких випадках слід застосовувати <? super T>, <? extends T>, а в яких просто <T> без super або extends?

Символи `<? super T>` та `<? extends T>` використовуються для вказівки діапазону типів в обмеженнях дженериків в Java. Основна різниця між ними полягає у тому, як вони обмежують можливості використання типів.

1. **<? super T>:**
   - `<? super T>` вказує на те, що можна використовувати будь-який тип, який є суперкласом для типу `T` або сам `T`. Іншими словами, це означає, що можна використовувати будь-який тип, який є або є батьківським класом для `T`.
   - Зазвичай `<? super T>` використовується, коли потрібно здійснити запис або зберегти об'єкт певного типу, але цей тип може бути будь-яким супертипом (батьківським класом) для заданого типу `T`.
   - Приклад:
     ```java
     List<? super Number> list = new ArrayList<>();
     list.add(new Integer(10)); // Дозволено, оскільки Integer є підкласом Number
     list.add(new Double(3.14)); // Дозволено, оскільки Double є підкласом Number
     ```

2. **<? extends T>:**
   - `<? extends T>` вказує на те, що можна використовувати будь-який тип, який є підтипом для типу `T`. Це означає, що можна використовувати будь-який тип, який є або є підкласом для `T`.
   - `<? extends T>` зазвичай використовується, коли потрібно отримати дані з колекції або іншої структури даних, але дозволяється використання тільки методів, що повертають дані (методи без параметрів).
   - Приклад:
     ```java
     List<? extends Number> list = new ArrayList<>();
     Number num = list.get(0); // Ок, оскільки метод get повертає Number або його підклас
     // list.add(new Integer(10)); // Недопустимо, оскільки неможливо визначити тип для додавання
     ```

3. **Просто <T> без super або extends:**
   - Коли в обмеженнях дженериків використовується просто `<T>`, це означає, що тип `T` використовується напряму без обмежень на його супертипи або підтипи.
   - Це найбільш загальний випадок і використовується, коли немає специфічних обмежень на тип `T`.

Отже, в яких випадках слід застосовувати `<? super T>`, `<? extends T>`, а в яких просто `<T>` залежить від конкретної ситуації:
- `<? super T>` використовується для запису/збереження в колекцію об'єктів типу `T` або його супертипів.
- `<? extends T>` використовується для отримання даних з колекції, але не дозволяє використання методів, які модифікують дані (наприклад, `add`), оскільки немає гарантії, що тип `T` буде підтипом для всіх елементів колекції.
- `<T>` без `super` або `extends` використовується у випадках, коли не потрібно обмежувати тип `T` його супертипами або підтипами.
---
## Висновки: у ході цієї лаборатроної роботи ми здобули нові знання у сфері роботи зі змінними, а також змогли відпрацювати це теоретично та на практиці.
